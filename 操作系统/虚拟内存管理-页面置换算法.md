#### 功能
当缺页中断发生时，需要调入新的页面，内存已满时，选择内存中哪个物理页面被替换
#### 目标
尽可能地减少页面的换进换出次数（即缺页中断的次数）
#### 页面锁定
不进行页面置换的程序
#### 最优页面置换算法
  * 当缺页发生时，计算将来访问还需要多少时间，最长的替换出去
  * 可用作其他算法性能评价的依据
## 局部页面置换算法（针对一个应用程序）
#### 先进先出算法 FIFO
* 基本思路
  * 选择内存中驻留时间最长的页面淘汰
  * 性能较差
#### 最近最久未使用算法 LRU
* 基本思路
  * 选择最久未被使用
  * 对最久页面置换算法的近似，依据程序局部性原理
  * 开销大
  * 实现
    * 链表
    * 栈
#### 时钟页面置换算法 Clock
* LRU的近似，对FIFO的一种改进
* 基本思路
  * 用到页表项的访问位
  * 把各个页面组织成环形链表，把指针指向最老的页面
  * 缺页时，如果访问位为1，接着走，如果为0，发生替换
  * 走一下，把对应项的访问位改成0
* 对脏页的替换代价比较大
#### 二次机会算法 Enhaced Clock
* 与 Clock 类似
* 基本思路
  * 缺页时，选择时，脏位和访问位都是0，发生替换
  * 走一下
  * 如果对应项脏位是0，访问位是1，把访问位为0
  * 如果对应项脏位是1，访问位是1，把访问位为0
  * 如果对应项脏位是1，访问位是0，把脏位置为0
#### 最不常用算法 LFU
* 基本思路
  * 当一个缺页中断发生时，选择访问次数最少的那个页面，并淘汰之
* 劣势
  * 一个程序开始用的很多，后面不用了
#### Belady现象
在采用FIFO算法时，有时候出现分配的物理页面数增加，缺页率反而上升的异常现象。
* 不满足栈算法特点
LRU算法不会
* 符合栈算法特点
Clock算法
* 也会
二次机会算法
* 也会
#### 比较
* FIFO  开销小，性能差
* LRU   具有局部性效果好，不具有局部性退化为FIFO，开销大，性能好
* Clock 类似FIFO的算法，利用了几个bit去近似LRU算法，不具有局部性退化为FIFO，折中
## 局部页面替换算法的缺点
给每个程序分配固定的物理页帧大小，会限制程序的灵活性
## 工作集模型
上述算法都基于一个前提，即程序的局部性原理
* 如果局部性不成立，各种页面替换算法没什么区别
* 如果成立，如何证明他的存在，如何对他进行定量的分析？这就是工作集模型
* Working set
* 定义
  * 一个进程当前正在使用的逻辑页面的集合，可以用一个二元函数$W(t, \Delta)$来表示
  * t 是当前执行的时刻
  * $\Delta$ 成为工作集窗口（working-set window）
  * $W(t, \Delta) =$ 在当前时刻 t 之前的 $\Delta$ 时间窗口中的所有页面组成的集合，随着 t 变化，该集合也在不断变化
  * $|W(t, \Delta)|$ 指工作集的大小
* 常驻集
  * 当前时刻，进程实际驻留在内存中的页面集合 
## 全局页面置换算法
#### 工作集替换算法
* 基本思路
  * 追踪之前 t 个引用（t 是 窗口大小）
  * 缺页时替换
  * 前 t 个里消失时去除
#### 缺页率页面置换算法 PFF，page fault frequency
* 基本思路
  * 缺页率：$\frac{缺页次数}{内存访问次数}$
  * 运行的缺页率过高，增加工作集
  * 运行的缺页率过低，减小工作集
  * 这一次的缺页中断和上一次的缺页中断差值，设定一个阈值，小于等于就把上次缺页也放进来
  * 大于就按照工作集替换算法干
## 抖动问题
如果分配给一个进程的物理页面太少，进程会造成很多缺页中断，从而使进程运行速度慢，成为抖动
原因： 